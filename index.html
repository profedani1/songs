<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pecera 3D: Esfera flabber bailando con m√∫sica</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; cursor: grab; touch-action: none; }
  canvas:active { cursor: grabbing; }

  .edge-overlay {
    position: fixed;
    pointer-events: none;
    z-index: 10;
  }
  #edge-left, #edge-right, #edge-top, #edge-bottom {
    background: linear-gradient(to right, rgba(255,0,255,0.3), transparent);
  }
  #edge-left, #edge-right {
    top: 0; width: 150px; height: 100vh;
  }
  #edge-left { left: 0; }
  #edge-right { right: 0; background: linear-gradient(to left, rgba(0,255,255,0.3), transparent); }

  #edge-top, #edge-bottom {
    left: 0; width: 100vw; height: 150px;
  }
  #edge-top { top: 0; background: linear-gradient(to bottom, rgba(255,0,255,0.3), transparent); }
  #edge-bottom { bottom: 0; background: linear-gradient(to top, rgba(0,255,255,0.3), transparent); }

  #lockStatus {
    position: fixed;display:none;
    top: 20px;
    left: 20px;
    color: transparent;
    font-weight: bold;
    font-family: monospace;
    user-select: none;
    z-index: 20;
  }
</style>
</head>
<body>

<div id="edge-left" class="edge-overlay"></div>
<div id="edge-right" class="edge-overlay"></div>
<div id="edge-top" class="edge-overlay"></div>
<div id="edge-bottom" class="edge-overlay"></div>

<div id="lockStatus">Unlocked</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const pointLight = new THREE.PointLight(0x00FFFF, 50);
pointLight.position.set(10,10,10);
scene.add(pointLight);
scene.add(new THREE.AmbientLight(0xffffff, 0.5));

const radius = 3;
const geometry = new THREE.SphereGeometry(radius, 100, 100);

let basePositions = new Float32Array(geometry.attributes.position.array);
const positionAttribute = geometry.attributes.position;
const vertexCount = positionAttribute.count;

// Shader material with dynamic color
const material = new THREE.ShaderMaterial({
  wireframe: true,
  uniforms: {
    colorMix: { value: 0.0 }
  },
  vertexShader: `
    varying vec3 vPosition;
    void main() {
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vPosition;
    uniform float colorMix; // 0 = normal, 1 = lime flash

    vec3 magenta = vec3(1.0,0.0,1.0);
    vec3 cyan = vec3(0.0,1.0,1.0);
    vec3 lime = vec3(0.5,1.0,0.0);

    void main() {
      float baseMix = (vPosition.x + ${radius.toFixed(1)}) / ${(radius*2).toFixed(1)};
      vec3 baseColor = mix(magenta, cyan, baseMix);
      vec3 color = mix(baseColor, lime, colorMix);
      gl_FragColor = vec4(color,1.0);
    }
  `
});

const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);

const boxSize = 20;
const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
const boxMaterial = new THREE.MeshBasicMaterial({
  color: 0xffffff,
  wireframe: true,
  transparent: true,
  opacity: 0 // Adjust this value to control transparency
});

const box = new THREE.Mesh(boxGeometry, boxMaterial);
scene.add(box);

let sphereAngleY = 0;
let sphereAngleX = 0;
const sphereLimit = Math.PI/2 - 0.1;

let camPos = new THREE.Vector3(0,0,10);
let camPosTarget = camPos.clone();
let camYaw = Math.PI;
let camPitch = 0;
const camPitchLimit = Math.PI/2 - 0.1;

let isDraggingSphere = false;
let lastMouse = {x:0, y:0};
let mousePos = {x: window.innerWidth/2, y: window.innerHeight/2};

const sphereDragSensitivity = 0.005;
const camMouseSensitivity = 0.002;
const moveSpeed = 0.1;
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// --- AUDIO SETUP ---
let audioCtx, analyser, dataArray;
let audioSource;
let audioReady = false;

const audio = new Audio('https://raw.githubusercontent.com/profedani1/songs/main/molotov.mp3');
audio.crossOrigin = "anonymous";
audio.loop = true;
audio.preload = "auto";

let isPlaying = false;

// Initialize audio context and analyser on first play
async function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioSource = audioCtx.createMediaElementSource(audio);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    audioSource.connect(analyser);
    analyser.connect(audioCtx.destination);
  }
}

// --- LOCK CAMERA VIEW ON LEFT+RIGHT CLICK ---

let leftDown = false;
let rightDown = false;
let viewLocked = false;
const lockStatus = document.getElementById('lockStatus');

function updateLockStatus() {
  lockStatus.textContent = viewLocked ? 'View Locked' : 'Unlocked';
  lockStatus.style.color = viewLocked ? 'lime' : 'white';
}

renderer.domElement.addEventListener('mousedown', e => {
  if (e.button === 0) leftDown = true;
  if (e.button === 2) rightDown = true;

  if (leftDown && rightDown) {
    viewLocked = !viewLocked;
    updateLockStatus();
  }

  if (!viewLocked && e.button === 0) {
    isDraggingSphere = true;
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  }
});
renderer.domElement.addEventListener('mouseup', e => {
  if (e.button === 0) leftDown = false;
  if (e.button === 2) rightDown = false;
  isDraggingSphere = false;
});
renderer.domElement.addEventListener('mouseleave', () => {
  isDraggingSphere = false;
  leftDown = false;
  rightDown = false;
});
renderer.domElement.addEventListener('mousemove', e => {
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;

  if(!viewLocked && isDraggingSphere) {
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    sphereAngleY += dx * sphereDragSensitivity;
    sphereAngleX += dy * sphereDragSensitivity;
    sphereAngleX = Math.max(-sphereLimit, Math.min(sphereAngleX, sphereLimit));
    sphere.rotation.y = sphereAngleY;
    sphere.rotation.x = sphereAngleX;
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  } else if (!viewLocked) {
    // Adjust camera yaw/pitch with mouse movement if not locked and not dragging sphere
    const dx = e.movementX || e.clientX - lastMouse.x;
    const dy = e.movementY || e.clientY - lastMouse.y;
    camYaw -= dx * camMouseSensitivity;
    camPitch -= dy * camMouseSensitivity;
    camPitch = Math.max(-camPitchLimit, Math.min(camPitch, camPitch));
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  }
});

// Prevent context menu on right click
document.addEventListener('contextmenu', e => {
  e.preventDefault();
});

window.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomSpeed = 0.005;
  const zoomAmount = -e.deltaY * zoomSpeed;
  const lookDir = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    Math.sin(camPitch),
    Math.cos(camPitch)*Math.cos(camYaw)
  );
  camPosTarget.add(lookDir.multiplyScalar(zoomAmount));
}, { passive: false });

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// --- FLABBER DANCING WOBBLING & COLOR CHANGE on BEAT ---

// Smooth oscillation helper
function smoothOscillation(time, freq=3, phase=0, amplitude=1) {
  return amplitude * Math.sin(freq * time + phase);
}

function distortGeometry(time) {
  if (!audioReady && analyser) audioReady = true;
  if (audioReady && analyser) {
    analyser.getByteFrequencyData(dataArray);

    // Calculate overall volume / beat strength (RMS-like)
    let sumSquares = 0;
    for (let i=0; i < dataArray.length; i++) {
      const val = dataArray[i]/255;
      sumSquares += val * val;
    }
    const rms = Math.sqrt(sumSquares / dataArray.length);

    // Use RMS for wobbling amplitude, capped reasonably
    const wobbleAmp = 0.5 * rms;

    // Flash color when beat is strong enough
    let flashThreshold = 0.35;
    let colorMix = (rms > flashThreshold) ? (rms - flashThreshold)*4 : 0.0;
    colorMix = Math.min(colorMix, 1.0);
    material.uniforms.colorMix.value = colorMix;

    for(let i=0; i < vertexCount; i++) {
      const ix = i*3;
      let x0 = basePositions[ix];
      let y0 = basePositions[ix+1];
      let z0 = basePositions[ix+2];

      // Calculate a blob-like oscillation on radius using spherical coords
      const len0 = Math.sqrt(x0*x0 + y0*y0 + z0*z0);
      const normX = x0 / len0;
      const normY = y0 / len0;
      const normZ = z0 / len0;

      // Oscillate radius with combination of sines for fun effect
      let osc = 0;
      osc += smoothOscillation(time, 3, normX * 10, wobbleAmp);
      osc += smoothOscillation(time, 5, normY * 15, wobbleAmp * 0.7);
      osc += smoothOscillation(time, 7, normZ * 20, wobbleAmp * 0.5);

      // Add a slow pulse
      osc += wobbleAmp * 0.2 * Math.sin(time * 1.5 + normX*normY*normZ*50);

      const newRadius = radius + osc;

      positionAttribute.array[ix] = normX * newRadius;
      positionAttribute.array[ix+1] = normY * newRadius;
      positionAttribute.array[ix+2] = normZ * newRadius;
    }
    positionAttribute.needsUpdate = true;
  }
}

function updateCamera() {
  camera.position.copy(camPos);
  const dir = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    Math.sin(camPitch),
    Math.cos(camPitch)*Math.cos(camYaw)
  );
  camera.lookAt(camPos.clone().add(dir));
}

function moveCamera() {
  const forward = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    0,
    Math.cos(camPitch)*Math.cos(camYaw)
  ).normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  if(keys['w']) camPosTarget.add(forward.clone().multiplyScalar(moveSpeed));
  if(keys['s']) camPosTarget.add(forward.clone().multiplyScalar(-moveSpeed));
  if(keys['a']) camPosTarget.add(right.clone().multiplyScalar(-moveSpeed));
  if(keys['d']) camPosTarget.add(right.clone().multiplyScalar(moveSpeed));
  if(keys[' ']) camPosTarget.y += moveSpeed;
  if(keys['shift']) camPosTarget.y -= moveSpeed;

  const limit = boxSize/2 - 0.5;
  camPosTarget.x = Math.min(limit, Math.max(-limit, camPosTarget.x));
  camPosTarget.y = Math.min(limit, Math.max(-limit, camPosTarget.y));
  camPosTarget.z = Math.min(limit, Math.max(-limit, camPosTarget.z));

  camPos.lerp(camPosTarget, 0.1);
}

const edgeSize = 150;
const autoLookSpeed = 0.02;

function autoRotateViewByMousePosition() {
  if(viewLocked || isDraggingSphere) return;
  if(mousePos.x < edgeSize) camYaw += autoLookSpeed * (edgeSize - mousePos.x) / edgeSize;
  else if(mousePos.x > window.innerWidth - edgeSize) camYaw -= autoLookSpeed * (mousePos.x - (window.innerWidth - edgeSize)) / edgeSize;
  if(mousePos.y < edgeSize) camPitch += autoLookSpeed * (edgeSize - mousePos.y) / edgeSize;
  else if(mousePos.y > window.innerHeight - edgeSize) camPitch -= autoLookSpeed * (mousePos.y - (window.innerHeight - edgeSize)) / edgeSize;

  camPitch = Math.max(-camPitchLimit, Math.min(camPitch, camPitch));
}

// --- Play/pause toggle by clicking the sphere ---

// Track clicks for double-click-like toggle
let lastClickTime = 0;
const doubleClickThreshold = 300; // ms

renderer.domElement.addEventListener('click', async (event) => {
  // If dragging, ignore click to avoid toggling
  if (isDraggingSphere) return;

  // Use raycaster to detect if click is on the sphere
  const mouse = new THREE.Vector2(
    (event.clientX / window.innerWidth) * 2 - 1,
    - (event.clientY / window.innerHeight) * 2 + 1
  );
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(sphere);

  if (intersects.length > 0) {
    const now = performance.now();
    if (now - lastClickTime < doubleClickThreshold) {
      // Double click detected: toggle pause/play
      if (isPlaying) {
        audio.pause();
        isPlaying = false;
      } else {
        await initAudio();
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        audio.play();
        isPlaying = true;
      }
      lastClickTime = 0; // reset to avoid triple toggle
    } else {
      // Single click: start playing if stopped
      if (!isPlaying) {
        await initAudio();
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        audio.play();
        isPlaying = true;
      }
      lastClickTime = now;
    }
  }
});

function animate(t=0) {
  requestAnimationFrame(animate);
  const time = t * 0.001;
  distortGeometry(time);
  moveCamera();
  autoRotateViewByMousePosition();
  updateCamera();
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
