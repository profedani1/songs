<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pecera 3D: Esfera que vibra con la mÃºsica</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; cursor: grab; touch-action: none; }
  canvas:active { cursor: grabbing; }

  .edge-overlay {
    position: fixed;
    pointer-events: none;
    z-index: 10;
  }
  #edge-left, #edge-right, #edge-top, #edge-bottom {
    background: linear-gradient(to right, rgba(255,0,255,0.3), transparent);
  }
  #edge-left, #edge-right {
    top: 0; width: 150px; height: 100vh;
  }
  #edge-left { left: 0; }
  #edge-right { right: 0; background: linear-gradient(to left, rgba(0,255,255,0.3), transparent); }

  #edge-top, #edge-bottom {
    left: 0; width: 100vw; height: 150px;
  }
  #edge-top { top: 0; background: linear-gradient(to bottom, rgba(255,0,255,0.3), transparent); }
  #edge-bottom { bottom: 0; background: linear-gradient(to top, rgba(0,255,255,0.3), transparent); }
</style>
</head>
<body>

<div id="edge-left" class="edge-overlay"></div>
<div id="edge-right" class="edge-overlay"></div>
<div id="edge-top" class="edge-overlay"></div>
<div id="edge-bottom" class="edge-overlay"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.PointLight(0x00FFFF, 50);
light.position.set(10,10,10);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.5));

const radius = 3;
const geometry = new THREE.SphereGeometry(radius, 100, 100);
const material = new THREE.ShaderMaterial({
  wireframe: true,
  vertexShader: `
    varying vec3 vPosition;
    void main() {
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vPosition;
    vec3 magenta = vec3(1.0,0.0,1.0);
    vec3 cyan = vec3(0.0,1.0,1.0);
    void main() {
      float mixValue = (vPosition.x + ${radius.toFixed(1)}) / ${(radius*2).toFixed(1)};
      vec3 color = mix(magenta, cyan, mixValue);
      gl_FragColor = vec4(color,1.0);
    }
  `
});
const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);
const positionAttribute = geometry.attributes.position;
const vertexCount = positionAttribute.count;
const basePositions = new Float32Array(positionAttribute.array);

const boxSize = 20;
const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
const boxMaterial = new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true});
const box = new THREE.Mesh(boxGeometry, boxMaterial);
scene.add(box);

let sphereAngleY = 0;
let sphereAngleX = 0;
const sphereLimit = Math.PI/2 - 0.1;

let camPos = new THREE.Vector3(0,0,10);
let camPosTarget = camPos.clone();
let camYaw = Math.PI;
let camPitch = 0;
const camPitchLimit = Math.PI/2 - 0.1;

let isDraggingSphere = false;
let lastMouse = {x:0, y:0};
let mousePos = {x: window.innerWidth/2, y: window.innerHeight/2};

const sphereDragSensitivity = 0.005;
const camMouseSensitivity = 0.002;
const moveSpeed = 0.1;
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// ðŸŽµ AUDIO ANALYSIS SETUP
let audioCtx, analyser, dataArray;
let audioReady = false;

const audio = new Audio('https://raw.githubusercontent.com/profedani1/songs/main/molotov.mp3');
audio.crossOrigin = "anonymous";
audio.loop = true;
audio.autoplay = true;

audio.addEventListener('canplay', () => {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioCtx.createMediaElementSource(audio);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 128;
  dataArray = new Uint8Array(analyser.frequencyBinCount);

  source.connect(analyser);
  analyser.connect(audioCtx.destination);
  audioReady = true;
});

audio.play();

// ðŸŒ€ DISTORTION WITH AUDIO
function distortGeometry(time) {
  if (audioReady && analyser) {
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    const avg = sum / dataArray.length;
    const audioFactor = avg / 255;
    const strength = 0.4 + audioFactor * 1.5;

    for (let i = 0; i < vertexCount; i++) {
      const ix = i * 3;
      let x = basePositions[ix];
      let y = basePositions[ix+1];
      let z = basePositions[ix+2];

      const len = Math.sqrt(x*x + y*y + z*z);
      const offset = strength * Math.sin(Math.PI*x + time) * Math.cos(Math.PI*y + time);
      const scale = (radius + offset) / len;

      positionAttribute.array[ix] = x * scale;
      positionAttribute.array[ix+1] = y * scale;
      positionAttribute.array[ix+2] = z * scale;
    }
    positionAttribute.needsUpdate = true;
  }
}

function updateCamera() {
  camera.position.copy(camPos);
  const dir = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    Math.sin(camPitch),
    Math.cos(camPitch)*Math.cos(camYaw)
  );
  camera.lookAt(camPos.clone().add(dir));
}

function moveCamera() {
  const forward = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    0,
    Math.cos(camPitch)*Math.cos(camYaw)
  ).normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  if(keys['w']) camPosTarget.add(forward.clone().multiplyScalar(moveSpeed));
  if(keys['s']) camPosTarget.add(forward.clone().multiplyScalar(-moveSpeed));
  if(keys['a']) camPosTarget.add(right.clone().multiplyScalar(-moveSpeed));
  if(keys['d']) camPosTarget.add(right.clone().multiplyScalar(moveSpeed));
  if(keys[' ']) camPosTarget.y += moveSpeed;
  if(keys['shift']) camPosTarget.y -= moveSpeed;

  const limit = boxSize/2 - 0.5;
  camPosTarget.x = Math.min(limit, Math.max(-limit, camPosTarget.x));
  camPosTarget.y = Math.min(limit, Math.max(-limit, camPosTarget.y));
  camPosTarget.z = Math.min(limit, Math.max(-limit, camPosTarget.z));

  camPos.lerp(camPosTarget, 0.1);
}

const edgeSize = 150;
const autoLookSpeed = 0.02;

function autoRotateViewByMousePosition() {
  if(isDraggingSphere) return;
  if(mousePos.x < edgeSize) camYaw += autoLookSpeed * (edgeSize - mousePos.x) / edgeSize;
  else if(mousePos.x > window.innerWidth - edgeSize) camYaw -= autoLookSpeed * (mousePos.x - (window.innerWidth - edgeSize)) / edgeSize;
  if(mousePos.y < edgeSize) camPitch += autoLookSpeed * (edgeSize - mousePos.y) / edgeSize;
  else if(mousePos.y > window.innerHeight - edgeSize) camPitch -= autoLookSpeed * (mousePos.y - (window.innerHeight - edgeSize)) / edgeSize;

  camPitch = Math.max(-camPitchLimit, Math.min(camPitch, camPitch));
}

renderer.domElement.addEventListener('mousedown', e => {
  isDraggingSphere = true;
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});
renderer.domElement.addEventListener('mouseup', () => isDraggingSphere = false);
renderer.domElement.addEventListener('mouseleave', () => isDraggingSphere = false);
renderer.domElement.addEventListener('mousemove', e => {
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;

  if(isDraggingSphere) {
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    sphereAngleY += dx * sphereDragSensitivity;
    sphereAngleX += dy * sphereDragSensitivity;
    sphereAngleX = Math.max(-sphereLimit, Math.min(sphereAngleX, sphereLimit));
    sphere.rotation.y = sphereAngleY;
    sphere.rotation.x = sphereAngleX;
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  } else {
    const dx = e.movementX || e.clientX - lastMouse.x;
    const dy = e.movementY || e.clientY - lastMouse.y;
    camYaw -= dx * camMouseSensitivity;
    camPitch -= dy * camMouseSensitivity;
    camPitch = Math.max(-camPitchLimit, Math.min(camPitch, camPitch));
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  }
});

window.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomSpeed = 0.005;
  const zoomAmount = -e.deltaY * zoomSpeed;
  const lookDir = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    Math.sin(camPitch),
    Math.cos(camPitch)*Math.cos(camYaw)
  );
  camPosTarget.add(lookDir.multiplyScalar(zoomAmount));
}, { passive: false });

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate(t=0) {
  requestAnimationFrame(animate);
  const time = t * 0.001;
  distortGeometry(time);
  moveCamera();
  autoRotateViewByMousePosition();
  updateCamera();
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
