<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Pecera 3D con Joysticks</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; touch-action: none; }

    .joystick {
      position: fixed;
      width: 25vw;
      height: 25vw;
      max-width: 150px;
      max-height: 150px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255,255,255,0.2);
      touch-action: none;
      z-index: 10;
    }

    .thumb {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 40%;
      height: 40%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
    }

    #joystick-left { bottom: 10vh; left: 5vw; }
    #joystick-right { bottom: 10vh; right: 5vw; }

    #zoom-slider {
      position: fixed;
      left: 50%;
      bottom: 10vh;
      width: 8vw;
      height: 25vw;
      max-height: 150px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      transform: translateX(-50%);
      z-index: 10;
    }

    #zoom-thumb {
      position: absolute;
      width: 100%;
      height: 20%;
      background: rgba(255,255,255,0.3);
      border-radius: 10px;
      top: 40%;
      transform: translateY(-50%);
    }
  </style>
</head>
<body>
<div id="joystick-left" class="joystick"><div class="thumb"></div></div>
<div id="joystick-right" class="joystick"><div class="thumb"></div></div>
<div id="zoom-slider"><div id="zoom-thumb"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Iluminación
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const light = new THREE.PointLight(0x00ffff, 50);
light.position.set(10,10,10);
scene.add(light);

// Esfera
const radius = 3;
const geometry = new THREE.SphereGeometry(radius, 100, 100);
const basePositions = new Float32Array(geometry.attributes.position.array);
const positionAttribute = geometry.attributes.position;
const vertexCount = positionAttribute.count;

const material = new THREE.ShaderMaterial({
  wireframe: true,
  uniforms: { colorMix: { value: 0.0 } },
  vertexShader: `
    varying vec3 vPosition;
    void main() {
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vPosition;
    uniform float colorMix;
    vec3 magenta = vec3(1.0,0.0,1.0);
    vec3 cyan = vec3(0.0,1.0,1.0);
    vec3 lime = vec3(0.5,1.0,0.0);
    void main() {
      float baseMix = (vPosition.x + ${radius.toFixed(1)}) / ${(radius*2).toFixed(1)};
      vec3 baseColor = mix(magenta, cyan, baseMix);
      vec3 color = mix(baseColor, lime, colorMix);
      gl_FragColor = vec4(color,1.0);
    }
  `
});
const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);

// Caja límite
const boxSize = 20;
scene.add(new THREE.Mesh(
  new THREE.BoxGeometry(boxSize, boxSize, boxSize),
  new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 })
));

// Cámara
let camPos = new THREE.Vector3(0,0,10);
let camPosTarget = camPos.clone();
let camYaw = Math.PI;
let camPitch = 0;
const camPitchLimit = Math.PI/2 - 0.1;

// Movimiento
const moveSpeed = 0.02;
function updateCamera() {
  camera.position.copy(camPos);
  const dir = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    Math.sin(camPitch),
    Math.cos(camPitch)*Math.cos(camYaw)
  );
  camera.lookAt(camPos.clone().add(dir));
}
function moveCamera() {
  const forward = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw), 0,
    Math.cos(camPitch)*Math.cos(camYaw)
  ).normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  camPosTarget.add(right.clone().multiplyScalar(leftJoystick.x * moveSpeed));
  camPosTarget.y += leftJoystick.y * moveSpeed;

  camYaw -= rightJoystick.x * 0.015;
  camPitch += rightJoystick.y * 0.015; // Inversión aplicada (antes restaba)
  camPitch = Math.max(-camPitchLimit, Math.min(camPitch, camPitchLimit));

  const zoomAmount = zoomDelta * moveSpeed * 2;
  const zoomDir = new THREE.Vector3(
    Math.cos(camPitch)*Math.sin(camYaw),
    Math.sin(camPitch),
    Math.cos(camPitch)*Math.cos(camYaw)
  );
  camPosTarget.add(zoomDir.multiplyScalar(zoomAmount));

  const limit = boxSize/2 - 0.5;
  camPosTarget.x = Math.min(limit, Math.max(-limit, camPosTarget.x));
  camPosTarget.y = Math.min(limit, Math.max(-limit, camPosTarget.y));
  camPosTarget.z = Math.min(limit, Math.max(-limit, camPosTarget.z));

  camPos.lerp(camPosTarget, 0.1);
}

// Geometría dinámica
function distortGeometry(t) {
  if (!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  let rms = 0;
  for (let i = 0; i < dataArray.length; i++) {
    const v = dataArray[i] / 255;
    rms += v * v;
  }
  rms = Math.sqrt(rms / dataArray.length);
  const wobbleAmp = 0.5 * rms;
  material.uniforms.colorMix.value = rms > 0.35 ? Math.min((rms - 0.35)*4, 1.0) : 0;

  for (let i = 0; i < vertexCount; i++) {
    const ix = i*3;
    let x0 = basePositions[ix], y0 = basePositions[ix+1], z0 = basePositions[ix+2];
    const len = Math.sqrt(x0**2 + y0**2 + z0**2);
    const nx = x0 / len, ny = y0 / len, nz = z0 / len;
    let osc = 0;
    osc += Math.sin(t*3 + nx*10)*wobbleAmp;
    osc += Math.sin(t*5 + ny*15)*wobbleAmp*0.7;
    osc += Math.sin(t*7 + nz*20)*wobbleAmp*0.5;
    osc += Math.sin(t*1.5 + nx*ny*nz*50)*wobbleAmp*0.2;
    const r = radius + osc;
    positionAttribute.array[ix] = nx*r;
    positionAttribute.array[ix+1] = ny*r;
    positionAttribute.array[ix+2] = nz*r;
  }
  positionAttribute.needsUpdate = true;
}

// Entrada: Joysticks y zoom
let leftJoystick = {x:0, y:0}, rightJoystick = {x:0, y:0}, zoomDelta = 0;

function setupJoystick(id, onMove) {
  const el = document.getElementById(id);
  const thumb = el.querySelector('.thumb');
  let origin = {x:0, y:0};
  let active = false;
  let activeTouchId = null;

  el.addEventListener('touchstart', e => {
    if (active) return; // ya hay un dedo activo
    const t = e.changedTouches[0];
    activeTouchId = t.identifier;
    origin = {x: t.clientX, y: t.clientY};
    active = true;
  }, {passive: false});

  el.addEventListener('touchmove', e => {
    if (!active) return;
    // buscar el toque con el id activo
    const touch = [...e.touches].find(t => t.identifier === activeTouchId);
    if (!touch) return;

    const dx = touch.clientX - origin.x;
    const dy = touch.clientY - origin.y;
    const val = {x: dx / 60, y: -dy / 60};
    onMove(val);
    thumb.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  }, {passive: false});

  el.addEventListener('touchend', e => {
    // si el dedo levantado es el activo, desactivamos
    if (!active) return;
    const endedTouch = [...e.changedTouches].find(t => t.identifier === activeTouchId);
    if (!endedTouch) return;
    onMove({x:0, y:0});
    thumb.style.transform = 'translate(-50%, -50%)';
    active = false;
    activeTouchId = null;
  }, {passive: false});
}

setupJoystick('joystick-left', val => leftJoystick = val);
setupJoystick('joystick-right', val => rightJoystick = val);

const zoomThumb = document.getElementById('zoom-thumb');
const zoomSlider = document.getElementById('zoom-slider');
let zoomOriginY = 0;
let zoomActiveTouchId = null;

zoomSlider.addEventListener('touchstart', e => {
  if (zoomActiveTouchId !== null) return; // ya activo con otro dedo
  const t = e.changedTouches[0];
  zoomActiveTouchId = t.identifier;
  zoomOriginY = t.clientY;
});
zoomSlider.addEventListener('touchmove', e => {
  if (zoomActiveTouchId === null) return;
  const touch = [...e.touches].find(t => t.identifier === zoomActiveTouchId);
  if (!touch) return;
  const dy = touch.clientY - zoomOriginY;
  zoomDelta = -dy / 100;
  zoomThumb.style.top = `${50 + dy}px`;
});
zoomSlider.addEventListener('touchend', e => {
  if (zoomActiveTouchId === null) return;
  const endedTouch = [...e.changedTouches].find(t => t.identifier === zoomActiveTouchId);
  if (!endedTouch) return;
  zoomDelta = 0;
  zoomThumb.style.top = '50%';
  zoomActiveTouchId = null;
});

// Audio
let audioCtx, analyser, dataArray;
const audio = new Audio('https://raw.githubusercontent.com/profedani1/songs/main/molotov.mp3');
audio.crossOrigin = "anonymous";
audio.loop = true;
audio.preload = "auto";
let isPlaying = false;

async function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaElementSource(audio);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    source.connect(analyser);
    analyser.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') await audioCtx.resume();
  audio.play(); isPlaying = true;
}

renderer.domElement.addEventListener('click', async e => {
  const mouse = new THREE.Vector2(
    (e.clientX / window.innerWidth) * 2 - 1,
    -(e.clientY / window.innerHeight) * 2 + 1
  );
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(sphere);
  if (intersects.length > 0) {
    if (isPlaying) { audio.pause(); isPlaying = false; }
    else await initAudio();
  }
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animación
function animate(t = 0) {
  requestAnimationFrame(animate);
  const time = t * 0.001;
  distortGeometry(time);
  moveCamera();
  updateCamera();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
